//@version=5
strategy("v1.321 Smart DCA Hedge", overlay=true, max_labels_count = 1, initial_capital=100, commission_type=strategy.commission.percent, commission_value=0.05, process_orders_on_close=true, margin_long = 15, margin_short = 15)

//--------------------------------------------------------------------------
// User Inputs
//--------------------------------------------------------------------------

// =========================================
// Backtest Date
// =========================================
bool limit_date_range                        = input.bool(title='Backtest Date', defval=true, group="Backtest Date")
int start_time                               = input.time(defval=timestamp('01 Jan 2025 00:00 +0000'), title='Start Time', group="Backtest Date")
int end_time                                 = input.time(defval=timestamp('31 Dec 2080 00:00 +0000'), title='End Time', group="Backtest Date")
in_date_range = true
if limit_date_range
    in_date_range := time >= start_time and time <= end_time
else
    in_date_range := true


// Basic strategy inputs
TP_percent            = input.float(1.5, title="Take Profit (%)", step=0.1) / 100
TP_increase_factor    = 1
recovery_zone_percent = input.float(2.0, title="Recovery Zone (%)", step=0.1) / 100
initial_position_size = input.float(1, title="Initial Position Size (% of equity)", step=0.15, minval=0.01, maxval=100) / 100
hedge_factor          = input.float(1.85, title="Hedge Factor", step=0.25)
max_qty               = 10000.0

// Stop loss configuration for hedging logic
stop_loss_percent_hedge = input.float(2.0, title="Stop Loss Percent for Hedge", step=0.1)
max_hedge_count = input.int(title='Max Hedge Count', tooltip = "Defines how many recovery trades to open", minval=2, maxval=10, defval=6)


// =========================================
// Stiffness @DavidTech
// =========================================

Use_Stiffness_Long = input(title='Use Stiffness For Enteries', defval=true)
Use_Stiffness_Recovery = input(title='Use Stiffness For Recovery', defval=false)

maLength = input.int(title='Moving Average Length', minval=1, defval=100)
stiffLength = input.int(title='Stiffness Length', minval=1, defval=60)
stiffSmooth = input.int(title='Stiffness Smoothing Length', minval=1, defval=3)
threshold = input.int(title='Threshold', minval=1, defval=90)
highlightThresholdCrossovers = false
disable_warnings = input.bool(true, "Disable Position sizing Warning")


bound = ta.sma(close, maLength) - 0.2 * ta.stdev(close, maLength)
sumAbove = math.sum(close > bound ? 1 : 0, stiffLength)
stiffness = ta.ema(sumAbove * 100 / stiffLength, stiffSmooth)

var bool Stiffness_Long = na
var bool Stiffness_Short = na

long_cond = ta.crossover(stiffness, threshold)
long_close = stiffness > threshold and ta.falling(stiffness, 1)
short_cond = ta.crossunder(stiffness, threshold) or stiffness < threshold and ta.falling(stiffness, 1)
short_close = stiffness < threshold and ta.rising(stiffness, 1)


transparent = color.new(color.white, 100)

if long_cond
    Stiffness_Long:= true
    Stiffness_Short:= false
else if short_cond
    Stiffness_Long:= false
    Stiffness_Short:= true


bgColor = highlightThresholdCrossovers ? stiffness > threshold ? #0ebb23 : color.red : transparent
bgcolor(bgColor, transp=90)

//plot(stiffness, title='Stiffness', style=plot.style_line, color=color.new(#f5c75e, 0))
//plot(threshold, title='Threshold', color=color.new(color.red, 0))

//--------------------------------------------------------------------------
// Variables
//--------------------------------------------------------------------------
var float long_tp       = na
var float short_tp      = na
var float long_recovery = na
var float short_recovery= na
var int   hedge_count   = 0

// Track initial equity for net realized PnL calculations
var float initial_equity = na
if bar_index == 0
    initial_equity := strategy.equity

// Track accumulated loss over time
var float accumulated_loss = 0.0

//--------------------------------------------------------------------------
// Helper Functions
//--------------------------------------------------------------------------

// Safely calculate quantity
f_calc_qty(_size, _factor, _hedge_count, _equity, _close, _max_qty) =>
    _raw_qty = (_size * math.pow(_factor, _hedge_count)) * _equity / _close
    _raw_qty := math.abs(_raw_qty)
    _raw_qty := math.max(_raw_qty, 0.01)
    _raw_qty := math.min(_raw_qty, _max_qty)
    _raw_qty

// Update accumulated_loss after any position close
f_update_accumulated_loss(_initial_equity) =>
    net_realized_pnl = strategy.equity - _initial_equity
    net_realized_pnl < 0 ? -net_realized_pnl : 0.0

// Calculate Long TP incorporating accumulated losses
f_calc_long_tp(_avg_price, _pos_size, _TP_percent, _acc_loss) =>
    _tp = _avg_price + (_acc_loss / _pos_size) + (_TP_percent * _avg_price)
    _tp

// Calculate Short TP incorporating accumulated losses
f_calc_short_tp(_avg_price, _pos_size, _TP_percent, _acc_loss) =>
    _tp = _avg_price - (_acc_loss / math.abs(_pos_size)) - (_TP_percent * _avg_price)
    _tp

//--------------------------------------------------------------------------
// Stop Loss and Hedge Condition Logic
//--------------------------------------------------------------------------

// Check if we have a long order active
Long_orderActive = strategy.position_size > 0

// Calculate Hedge Stop Loss level
Hedge_stopLoss = strategy.position_avg_price - (strategy.position_avg_price * stop_loss_percent_hedge / 100)

// Hedge condition: if price falls below stop loss level while long is active, trigger hedge condition
var bool Hedge_condition = false
if in_date_range and Long_orderActive and close < Hedge_stopLoss
    // Close the long position at stop loss
    strategy.close("Long", comment="Stop Loss Triggered")
    // Update accumulated_loss to reflect this realized loss
    accumulated_loss := f_update_accumulated_loss(initial_equity)
    // Set Hedge_condition so next initial trade can occur immediately
    Hedge_condition := true

//--------------------------------------------------------------------------
// Initial Trade Logic
//--------------------------------------------------------------------------

// The initial trade can occur either periodically or after a hedge condition (stop loss event)
condition_met = ((bar_index % 25 == 0) and (strategy.opentrades == 0)) or Hedge_condition and ((Use_Stiffness_Long and Stiffness_Long) or not Use_Stiffness_Long)

if in_date_range and condition_met 
    // Reset hedge condition after use
    Hedge_condition := false
    hedge_count := 2 //RESET
    // Enter initial short trade (as per the previous logic)
    initial_qty = f_calc_qty(initial_position_size, 1.0, 0, strategy.equity, close, max_qty)
    strategy.entry("Short", strategy.short, qty=initial_qty, comment="Initial Short after Stop Loss/Hedge or periodic")

//--------------------------------------------------------------------------
// Main Strategy Logic (example placeholders)
//--------------------------------------------------------------------------

// If long position is open, calculate TP and Recovery
if (strategy.opentrades > 0 and strategy.position_size > 0)
    long_tp := f_calc_long_tp(strategy.position_avg_price, strategy.position_size, TP_percent, accumulated_loss)
    long_recovery := strategy.position_avg_price * (1 - (recovery_zone_percent * (1 + (hedge_count / 100.0))))

// Close long at TP
if in_date_range and (strategy.opentrades > 0 and strategy.position_size > 0 and close >= long_tp)
    strategy.close("Long", comment="Take Profit - Hedge Count: " + str.tostring(hedge_count - 2))
    hedge_count := 2 //RESET
    accumulated_loss := f_update_accumulated_loss(initial_equity)

// Hedge from Long to Short if hitting recovery zone
if in_date_range and (strategy.opentrades > 0 and strategy.position_size > 0 and close <= long_recovery) and ((Use_Stiffness_Recovery and Stiffness_Long) or not Use_Stiffness_Recovery) and (hedge_count <= max_hedge_count)
    hedge_count += 1
    hedge_qty = f_calc_qty(initial_position_size, hedge_factor, hedge_count, strategy.equity, close, max_qty)
    strategy.close("Long")
    strategy.entry("Short", strategy.short, qty=hedge_qty, comment="Hedge Count: " + str.tostring(hedge_count - 2))
    accumulated_loss := f_update_accumulated_loss(initial_equity)

// If short position is open, calculate TP and Recovery
if (strategy.position_size < 0)
    short_tp := f_calc_short_tp(strategy.position_avg_price, strategy.position_size, TP_percent * TP_increase_factor, accumulated_loss)
else
    short_tp := na

short_recovery := strategy.position_avg_price * (1 + (recovery_zone_percent * (1 + (hedge_count / 100.0))))

// Close short at TP
if in_date_range and (strategy.opentrades > 0 and strategy.position_size < 0 and close <= short_tp + syminfo.mintick)
    strategy.close("Short", comment="Take Profit - Hedge Count: " + str.tostring(hedge_count - 2))
    hedge_count := 2 //RESET
    accumulated_loss := f_update_accumulated_loss(initial_equity)

// Hedge from Short back to Long if hitting short recovery zone
if in_date_range and (strategy.opentrades > 0 and strategy.position_size < 0 and close >= short_recovery) and ((Use_Stiffness_Recovery and Stiffness_Long) or not Use_Stiffness_Recovery) and (hedge_count <= max_hedge_count)
    hedge_count += 1
    hedge_qty = f_calc_qty(initial_position_size, hedge_factor, hedge_count, strategy.equity, close, max_qty)
    strategy.close("Short")
    strategy.entry("Long", strategy.long, qty=hedge_qty, comment="Hedge Count: " + str.tostring(hedge_count - 2))
    // Recalculate TP and Recovery for new long
    long_tp := f_calc_long_tp(strategy.position_avg_price, strategy.position_size, TP_percent * TP_increase_factor, accumulated_loss)
    long_recovery := strategy.position_avg_price * (1 - recovery_zone_percent)
    accumulated_loss := f_update_accumulated_loss(initial_equity)

//--------------------------------------------------------------------------
// Plot lines for visualization
//--------------------------------------------------------------------------
plot(not na(long_tp) ? long_tp : na, color=color.green, title="Long TP", linewidth=1, style = plot.style_circles)
plot(not na(long_recovery) ? long_recovery : na, color=color.blue, title="Long Recovery Zone", linewidth=1, style = plot.style_circles)
plot(not na(short_tp) ? short_tp : na, color=color.purple, title="Short TP", linewidth=1, style = plot.style_circles)
plot(not na(short_recovery) ? short_recovery : na, color=color.red, title="Short Recovery Zone", linewidth=1, style = plot.style_circles)


// Position sizing value (one line)
initial_position_size_cal = initial_position_size * 100
position_sizing_value = (initial_position_size_cal * (math.pow(hedge_factor, max_hedge_count)))


// Debug label (one line)
//label.new(bar_index, high, style=label.style_label_upper_left, text="Position Sizing Value: " + str.tostring(position_sizing_value), color=color.yellow, textcolor=color.black)
//label.new(bar_index, high, style=label.style_label_upper_left, text="accumulated_loss: " + str.tostring(accumulated_loss), color=color.yellow, textcolor=color.black)

if position_sizing_value > strategy.initial_capital and barstate.isconfirmed and not disable_warnings
    label.new(bar_index, low, style= label.style_label_upper_right ,text="!!WARNING!! \n VERIFY POSITION SIZING \n [Adjust the Initial Position Size, Hedge Factor, Max Hedge Count, until the strategy trades can be made with your account equity \n INCORRECT SETTINGS WILL CAUSE LIQUIDATION/LOSSES",color=color.red,textcolor=color.white,size=size.huge)
